#region Using Statements

using Artemis.Engine.Utilities;

using Microsoft.Xna.Framework;

using System;
using System.Collections.Generic;

#endregion

namespace Artemis.Engine.Effectors
{
    /// <summary>
    /// A class which represents an operation that an Effector uses
    /// to combine it's previous and next returned values.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    public class EffectorOperator<T>
    {

        protected virtual Dictionary<EffectorOperatorType, Func<T, T, T>> Operators { get { return null; } }

        /// <summary>
        /// The actual operation.
        /// </summary>
        public Func<T, T, T> Operate { get; private set; }

        /// <summary>
        /// The internal type of the operation (if it was instantiated using an
        /// EffectorOperatorType enum item).
        /// </summary>
        public EffectorOperatorType? InternalType { get; protected set; }

        internal EffectorOperator(EffectorOperatorType type)
        {
            InternalType = type;
            var _ops = Operators;
            if (_ops == null)
            {
                switch (type)
                {
                    case EffectorOperatorType.InPlace:
                        Operate = (a, b) => b;
                        break;
                    case EffectorOperatorType.Additive:
                        Operate = GenericOperators.Add<T>;
                        break;
                    case EffectorOperatorType.Multiplicative:
                        Operate = GenericOperators.Mul<T>;
                        break;
                    case EffectorOperatorType.ArithmeticAveraging:
                        Operate = GenericOperators.Average<T>;
                        break;
                    default:
                        throw new EffectorOperatorException(
                            String.Format(
                                "Unknown EffectorOperatorType supplied: '{0}'.", type
                                )
                            );
                }
            }
            else
            {
                Operate = _ops[type];
            }
        }

        internal EffectorOperator(Func<T, T, T> operate)
        {
            Operate = operate;
        }
    }

    // Implementing effector operators for these simple values prevents having to use 
    // the lambdas generated by GenericOperators, since those are unnecessarily slow
    // for simple types.

    public class IntEffectorOperator : EffectorOperator<int>
    {
        private Dictionary<EffectorOperatorType, Func<int, int, int>> _operators = 
            new Dictionary<EffectorOperatorType,Func<int,int,int>>()
        {
            { EffectorOperatorType.InPlace,             (a, b) => b },
            { EffectorOperatorType.Additive,            (a, b) => a + b },
            { EffectorOperatorType.Multiplicative,      (a, b) => a*b },
            { EffectorOperatorType.ArithmeticAveraging, (a, b) => (a + b)/2 }
        };

        protected override Dictionary<EffectorOperatorType, Func<int, int, int>> Operators
        {
            get { return _operators; }
        }

        internal IntEffectorOperator(EffectorOperatorType type) : base(type) { }
    }

    public class DoubleEffectorOperator : EffectorOperator<double>
    {
        private Dictionary<EffectorOperatorType, Func<double, double, double>> _operators =
            new Dictionary<EffectorOperatorType, Func<double, double, double>>()
        {
            { EffectorOperatorType.InPlace,             (a, b) => b },
            { EffectorOperatorType.Additive,            (a, b) => a + b },
            { EffectorOperatorType.Multiplicative,      (a, b) => a*b },
            { EffectorOperatorType.ArithmeticAveraging, (a, b) => (a + b)/2d }
        };

        protected override Dictionary<EffectorOperatorType, Func<double, double, double>> Operators
        {
            get { return _operators; }
        }

        internal DoubleEffectorOperator(EffectorOperatorType type) : base(type) { }
    }

    public class VectorEffectorOperator : EffectorOperator<Vector2>
    {
        private Dictionary<EffectorOperatorType, Func<Vector2, Vector2, Vector2>> _operators =
            new Dictionary<EffectorOperatorType, Func<Vector2, Vector2, Vector2>>()
        {
            { EffectorOperatorType.InPlace,             (a, b) => b },
            { EffectorOperatorType.Additive,            (a, b) => a + b },
            { EffectorOperatorType.Multiplicative,      (a, b) => a*b },
            { EffectorOperatorType.ArithmeticAveraging, (a, b) => (a + b)/2f }
        };

        protected override Dictionary<EffectorOperatorType, Func<Vector2, Vector2, Vector2>> Operators
        {
            get { return _operators; }
        }

        internal VectorEffectorOperator(EffectorOperatorType type) : base(type) { }
    }
}
